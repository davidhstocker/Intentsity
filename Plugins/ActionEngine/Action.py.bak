#!/usr/bin/env python2
"""Angela RML Interpreter - Action Queue (aQ) management engine service plugin
    Created by the project angela team
    http://sourceforge.net/projects/projectangela/
    http://www.projectangela.org"""
    
__license__ = "GPL"
__version__ = "$Revision: 0.1 $"
__author__ = 'David Stocker'


# ***** BEGIN GPL LICENSE BLOCK *****
#
# Module copyright (C) David Stocker 
#
# This module is part of the Angela RML Engine.

# Angela is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Angela is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Angela.  If not, see <http://www.gnu.org/licenses/>.
#
# ***** END GPL LICENCE BLOCK *****
# --------------------------------------------------------------------------

import copy
import uuid

import Graphyne.Graph as Graph
import Engine
import Angela
import Plugins.AngelaRML.Exceptions as Exceptions

    

#globals
moduleName = 'ActionEngine.Action'
logType = Graph.logTypes.CONTENT
logLevel = Graph.LogLevel()
actionInsertionTypes = Angela.ActionInsertionType()
scriptFacade = None


class Action(object):
    className = 'Action'
    actionIndex = {}  # parameter is the action engine's action index and is used later to inflate member lists
    
    def initialize(self, script, uuid, actionID):
        method = moduleName + '.' + self.className + '.' + 'initialize'
        """
            uuid = the uuid of the child action element (KeyFrame, Catch, Throw, etc.)
            actionID = the uuid of the parent Action element
        """
        Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            self.uuid = uuid
            self.meme = script.getEntityMemeType(actionID)
            self.actionID = actionID
            self.instanceID = None
        except Exception as e:
            errorMsg = "Unknown error initializing action %s.  Traceback = %s" %(actionID, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "exiting"])
        
        
    def refreshInstanceID(self):
        """
            Actions are singletons and self.uuid points back to the uuid of the memotica entity in the entity repository.
            Actions are initialized as singletons for performance reasons (to frontload the initialization overhead to server startup)
            and because actions of a given type are fungible.  However, we still want to have each instance of an action to have a 
            unique tracking ID for the lag-log's action life cycle tracking.
            
            Calling this method will generate a new UUID
        """
        method = moduleName + '.' + self.className + '.' + 'refreshInstanceID'
        try:
            self.instanceID = uuid.uuid1()
        except Exception as e:
            errorMsg = "Unknown error refreshing instance UUID on action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        
            
    def getInflatedMemberList(self, unusedScript):
        method = moduleName + '.' + self.className + '.' + 'getInflatedMemberList'
        try:
            return [self.meme]
        except:
            errorMsg = "Can't run getInflatedMemberList() on initialized action"
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])   
            return []  
        
        
    def inflateMembers(self, script):
        #this method is only relevant for sets
        pass       
    
    
            
    def addLandMarks(self, script):
        """
            Find all of the landmarks attached to the keyframe
        """
        method = moduleName + '.' + self.className + '.' + 'addLandMarks'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            # The template paths of the various types of landmarks
            lmExPath = u"Memotica.Action.RequiredLandmarks::Memotica.Action.RequiredlandmarksExclusive::Memotica.Action.RequiredLandmark::Memotica.Agent.Landmark"
            lmMPath = u"Memotica.Action.RequiredLandmarks::Memotica.Action.MasterLandmark::Memotica.Action.RequiredLandmark::Memotica.Agent.Landmark"
            lmNoExPath = u"Memotica.Action.RequiredLandmarks::Memotica.Action.RequiredLandmark::Memotica.Agent.Landmark"
            
            # Get the actual uuids of the various landmarks
            self.landmarksNonExclusive = script.getLinkCounterpartsByMetaMemeType(self.uuid, lmNoExPath)
            self.landmarksExclusive = script.getLinkCounterpartsByMetaMemeType(self.uuid, lmExPath)
            masterLandmarkList = script.getLinkCounterpartsByMetaMemeType(self.uuid, lmMPath)
            try:
                self.masterLandmark = masterLandmarkList[0]
            except:
                errorMsg = "Action %s has no master landmark defined" %self.meme
                raise Exceptions.MemeMembershipValidationError(errorMsg)
            
            self.landmarkTransforms = []
            reqLMRootPath = u"**::Memotica.Action.RequiredLandmark"
            reqLMPath = u"Memotica.Agent.Landmark"
            reqLMTransformPath = u"Memotica.Action.LandmarkTransform"
            reqLMRoots = script.getLinkCounterpartsByMetaMemeType(self.uuid, reqLMRootPath)
            for reqLMRoot in reqLMRoots:
                reqLMs = script.getLinkCounterpartsByMetaMemeType(reqLMRoot, reqLMPath)
                reqLMTransforms = script.getLinkCounterpartsByMetaMemeType(reqLMRoot, reqLMTransformPath)
                # Memotica.Action.LandmarkTransform is optional, but a transform element only makes sense if one exists
                if len(reqLMTransforms) > 0:
                    #Memotica.Agent.Offset
                    deltaX = None
                    deltaY = None
                    deltaZ = None
                    offsetDelta = script.getLinkCounterpartsByMetaMemeType(reqLMTransforms[0], u"Memotica.Agent.Offset")
                    if len(offsetDelta) > 0:
                        deltaX = script.getEntityPropertyValue(offsetDelta[0], u"x")
                        deltaY = script.getEntityPropertyValue(offsetDelta[0], u"y")
                        deltaZ = script.getEntityPropertyValue(offsetDelta[0], u"z")
                        
                    #Memotica.Agent.EuerAngles
                    rotationX = None
                    rotationY = None
                    rotationZ = None
                    euerAngles = script.getLinkCounterpartsByMetaMemeType(reqLMTransforms[0], u"Memotica.Agent.EuerAngles")
                    if len(euerAngles) > 0:
                        rotationXList = script.getLinkCounterpartsByMetaMemeType(euerAngles[0], u"Memotica.Agent.RotationX")
                        rotationYList = script.getLinkCounterpartsByMetaMemeType(euerAngles[0], u"Memotica.Agent.RotationY")
                        rotationZList = script.getLinkCounterpartsByMetaMemeType(euerAngles[0], u"Memotica.Agent.RotationZ")
                        rotationX = script.getEntityPropertyValue(rotationXList[0], u"Angle")
                        rotationY = script.getEntityPropertyValue(rotationYList[0], u"Angle")
                        rotationZ = script.getEntityPropertyValue(rotationZList[0], u"Angle")
                        
                    transformDict = {"deltaX" : deltaX, "deltaY" : deltaY, "deltaZ" : deltaZ, "rotationX" : rotationX, "rotationY" : rotationY, "rotationZ" : rotationZ}
                    self.landmarkTransforms.append([reqLMs[0], transformDict])
        except Exceptions.MemeMembershipValidationError as e:
            Graph.logQ.put( [logType , logLevel.WARNING , method , e])
        except Exception as e:
            errorMsg = "Unknown error adding landmarks to keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "exiting"])
            
            
            
    def checkLandmarks(self, script, agentUUID):
        method = moduleName + '.' + self.className + '.' + 'checkLandmarks'
        allTrue = False
        try:
            exTrue = self.checkExLists(script, agentUUID)
            nonExTrue = script.map(self.mapFunctionLandmarks, self.landmarksNonExclusive, agentUUID)
            masterTrue = script.map(self.mapFunctionLandmarks, [self.masterLandmark], agentUUID)
            allLandmarks = []
            allLandmarks.extend(exTrue)
            allLandmarks.extend(nonExTrue)
            allLandmarks.extend(masterTrue)
            
            if False not in allLandmarks:
                allTrue = True
        except Exception as e:
            errorMsg = "Unknown error checking landmarks for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        finally: return allTrue    
    
    def checkExLists(self, script, agentUUID):
        method = moduleName + '.' + self.className + '.' + 'checkExLists'
        try:
            exTrue = script.map(self.mapFunctionLandmarks, self.landmarksExclusive, agentUUID)
            return exTrue
        except Exception as e:
            errorMsg = "Unknown error checking exclusive landmarks for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False
        
        
    def mapFunctionLandmarks(self, landMarkID, agentUUID):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionLandmarks'
        try:
            scriptFacade = Graph.scriptFacade.getFacade()
            landMarkPath = scriptFacade.getEntityMemeType(landMarkID)
            localResult = scriptFacade.getHasCounterpartsByType(agentUUID, landMarkPath)
            return localResult 
        except Exception as e:
            errorMsg = "Unknown error mapping landmark %s for keyframe object of action %s.  Traceback = %s" %(landMarkPath, self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False             
        
        
    def bootstrap(self):
        pass
    
        
        
        
class ConditionalAction(object):
    className = 'ConditionalAction'
    
    def addConditions(self, script):
        method = moduleName + '.' + self.className + '.' + 'addConditions'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            self.conditions = []
            """ Adds conditions to those actions (KeyFrame, Throw) that require them  """
            conditionPath = u"DNA.Condition.Condition"
            conditionElements = script.getLinkCounterpartsByMetaMemeType(self.uuid, conditionPath)
            for conditionElement in conditionElements:
                Graph.logQ.put( [logType , logLevel.DEBUG , method , "adding condition %s to action %s" %(conditionElement, self.uuid)])
                self.conditions.append(conditionElement)
        except Exception as e:
            actionID = None
            try: actionID = self.meme
            except: pass
            errorMsg = "Unknown error adding conditions to action %s.  Traceback = %s" %(actionID, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "exiting"])
            
        
    def mapFunctionConditions(self, script, conditionUUID, argumentMap):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionConditions'
        try:
            localResult = script.evaluateEntity(conditionUUID, argumentMap, argumentMap["actionID"], argumentMap["subjectID"], argumentMap["controllerID"])
            return localResult  
        except Exception as e:
            actionID = None
            try: actionID = self.meme
            except: pass
            errorMsg = "Unknown error testing individual condition on action %s.  Traceback = %s" %(actionID, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False
    
    
    def checkConditions(self, script, argumentMap):
        method = moduleName + '.' + self.className + '.' + 'checkConditions'
        try:
            conditionResults = script.map(self.mapFunctionConditions, self.conditions, argumentMap)
            conditionsTrue = True
            if False in conditionResults:
                conditionsTrue = False
            return conditionsTrue
        except Exception as e:
            actionID = None
            try: actionID = self.meme
            except: pass
            errorMsg = "Unknown error testing conditions on action %s.  Traceback = %s" %(actionID, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False
    
    
    
class ActionSet(Action): 
    className = 'ActionSet'
    
    def bootstrap(self, script):
        method = moduleName + '.' + self.className + '.' + 'bootstrap'
        try:
            self.memberList = []
            self.packedMemberList = []
            self.addLandMarks(script)
            actionSetChildren = script.getLinkCounterpartsByMetaMemeType(self.uuid, u"Memotica.Action.ChoreographyStep")
            tempPrio = {}
            try: #lv2
                for actionSetChild in actionSetChildren:
                    priority = script.getEntityPropertyValue(actionSetChild, u"Priority")
                    action = script.getLinkCounterpartsByMetaMemeType(actionSetChild, u"Memotica.Action.Action")
                    tempPrio[priority] = action[0]#there should only be one action counterpart per ChoreographyStep
                    
                try: #lv3
                    implicitCatch = script.getEntityPropertyValue(self.uuid, u"ImplicitCatch")
                    if implicitCatch == True:
                        #If implicitCatch is true, then create a Memotica.Action.DefaultCatch 
                        #    and append it to self.packedMemberList before adding any other members
                        landmarkPath = u"Memotica.Action.RequiredLandmarks::Memotica.Action.MasterLandmark::Memotica.Action.RequiredLandmark::Memotica.Agent.Landmark"
                        landmarkID = script.getLinkCounterpartsByMetaMemeType(self.uuid, landmarkPath)
                        defaultCatchID = script.getEntityPropertyValue(landmarkID[0], 'DefaultCatch')
                        defaultCatchUUID = uuid.UUID(defaultCatchID)
                        defaultCatchMeme = script.getEntityMemeType(defaultCatchUUID)
                        self.packedMemberList.append(defaultCatchMeme)
                except Exception as e:
                    #level 3
                    pass
                try: #lv4
                    prioList = sorted(tempPrio.keys())
                    for prio in prioList:
                        sortedMemberUUID = tempPrio[prio]
                        sortedMember = script.getEntityMemeType(sortedMemberUUID)
                        #debug
                        #errorMsg = "Entity meme %s uuid = %s" %(sortedMemberUUID, tempPrio[prio])
                        #Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
                        #/debug
                        self.packedMemberList.append(sortedMember)
                except Exception as e:
                    errorMsg = "Unknown error setting up ChoreographyStep members on action %s.Traceback = %s" %(self.meme, e)
                    sortedMember = script.getEntityMemeType(sortedMemberUUID)
                    Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            except Exception as e:
                #level 2
                pass
        except Exception as e:
            errorMsg = "Unknown error bootstrapping choreography %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            #debug
            try:
                self.addLandMarks(script)
                actionSetChildren = script.getLinkCounterpartsByMetaMemeType(self.uuid, u"Memotica.Action.ChoreographyStep")
                tempPrio = {}
                for actionSetChild in actionSetChildren:
                    priority = script.getEntityPropertyValue(actionSetChild, u"Priority")
                    action = script.getLinkCounterpartsByMetaMemeType(actionSetChild, u"Memotica.Action.Action")
                    tempPrio[priority] = action
                    
                implicitCatch = script.getEntityPropertyValue(self.uuid, u"ImplicitCatch")
                if implicitCatch == True:
                    #If implicitCatch is true, then create a Memotica.Action.DefaultCatch 
                    #    and append it to self.packedMemberList before adding any other members
                    landmarkPath = u"Memotica.Action.RequiredLandmarks::Memotica.Action.MasterLandmark::Memotica.Action.RequiredLandmark::Memotica.Agent.Landmark"
                    landmarkID = script.getLinkCounterpartsByMetaMemeType(self.uuid, landmarkPath)
                    defaultCatchID = script.getEntityPropertyValue(landmarkID[0], 'DefaultCatch')
                    defaultCatchUUID = uuid.UUID(defaultCatchID)
                    defaultCatchMeme = script.getEntityMemeType(defaultCatchUUID)
                    self.packedMemberList.append(defaultCatchMeme)
                prioList = sorted(tempPrio)
                for prio in prioList:
                    sortedMemberUUID = uuid.UUID(tempPrio[prio])
                    sortedMember = script.getEntityMemeType(sortedMemberUUID)
                    self.packedMemberList.append(sortedMember)
            except:
                pass
        
      
            
    def getInflatedMemberList(self, script):
        method = moduleName + '.' + self.className + '.' + 'getInflatedMemberList'
        returnList = []
        for taskItem in self.packedMemberList:
            #First, assert that we even have this action indexed
            try:
                assert taskItem in self.actionIndex
                memberEntity = self.actionIndex[taskItem]
                memberEntityMembers = memberEntity.getInflatedMemberList(script)
                returnList.extend(memberEntityMembers)
            except AssertionError:
                errorMessage = "Action set %s has member %s, which is not indexed in action engine" %(self.meme, taskItem)
                Graph.logQ.put( [logType , logLevel.ERROR , method , errorMessage])
        #debug
        #debugMessage = "Action set %s has the following members: %s" %(self.meme, returnList)
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , debugMessage])
        #/debug
        return returnList
    
    
    
    def inflateMembers(self, script):
        inflatedmemberList = self.getInflatedMemberList(script) 
        self.memberList = inflatedmemberList


    
class KeyFrame(Action, ConditionalAction):
    className = 'KeyFrame'
    
    def bootstrap(self, script):
        self.addLandMarks(script)
        self.addConditions(script)
        self.addObjectSelectionConditions(script)
        self.addStateChanges(script)
        self.addStimuli(script)
        self.addControllers(script)
        self.addRestrictedView(script)
        self.addTimescale(script)
        
    
        
    def addObjectSelectionConditions(self, script):
        method = moduleName + '.' + self.className + '.' + 'addObjectSelectionConditions'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            conditionPath = u"Memotica.Action.ObjectSelectionCondition::DNA.Condition.Condition"
            self.objectSelectionConditions = script.getLinkCounterpartsByMetaMemeType(self.uuid, conditionPath)
        except Exception as e:
            errorMsg = "Unknown error adding object selection conditions to keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])

        
        
    def addStateChanges(self, script):  
        method = moduleName + '.' + self.className + '.' + 'addStateChanges'
        #Memotica.Action.StateChangeSet
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            self.stateChangesSimple = [] 
            self.stateChangesJoin = [] 
            self.stateChangesBreak = []
            self.stateChangeSuccessor = []
            
            stateChangeElements = script.getLinkCounterpartsByMetaMemeType(self.uuid, u"Memotica.Action.StateChangeSet")
            if len(stateChangeElements) > 0:
                #StateChangeSet is a switch and will have one of the following children:
                #    SimpleStateChange, LinkJoin, LinkBreak or SuccessorAction
                scElements = script.getLinkCounterpartsByMetaMemeType(stateChangeElements[0], u"Memotica.Action.SimpleStateChange")
                ljElements = script.getLinkCounterpartsByMetaMemeType(stateChangeElements[0], u"Memotica.Action.LinkJoin")
                lbElements = script.getLinkCounterpartsByMetaMemeType(stateChangeElements[0], u"Memotica.Action.LinkBreak")
                saElements = script.getLinkCounterpartsByMetaMemeType(stateChangeElements[0], u"Memotica.Action.SuccessorAction")
                
                for scElement in scElements:
                    #SimpleStateChange have two mandatory elements, a Change and a State, the latter of which extends DNA.Condition.AgentAttributeArgument
                    changeElements = script.getLinkCounterpartsByMetaMemeType(scElement, u"Memotica.Action.Change")
                    conditionIDs = script.getLinkCounterpartsByMetaMemeType(scElement, u"DNA.Condition.Condition")
                    
                    stateElements = script.getLinkCounterpartsByMetaMemeType(scElement, u"Memotica.Action.State")
                    statePath = script.getEntityPropertyValue(stateElements[0], u"SubjectArgumentPath")
                    
                    conditionalStimuli = self.getConditionalStimuli(script, scElement)
                    stateChange = StateChangeSimple(conditionIDs[0], conditionalStimuli)
                    stateChange.prime(changeElements[0], statePath)
                    self.stateChangesSimple.append(stateChange)
                    
                for ljElement in ljElements:
                    conditionIDs = script.getLinkCounterpartsByMetaMemeType(ljElement, u"DNA.Condition.Condition")
                    subjectPath = script.getEntityPropertyValue(ljElement, u"SubjectArgumentPath")
                    objectPath = script.getEntityPropertyValue(ljElement, u"ObjectArgumentPath")
                    linkTypeStr = script.getEntityPropertyValue(ljElement, u"LinkType")
                    
                    linkType = 0
                    if linkTypeStr == u"SubAtomic":
                        linkType = 1
                    conditionalStimuli = self.getConditionalStimuli(script, ljElement)
                    stateChange = StateChangeJoin(conditionIDs[0], conditionalStimuli)
                    stateChange.prime(subjectPath, objectPath, linkType)
                    self.stateChangesJoin.append(stateChange)
                    
                for lbElement in lbElements:
                    conditionIDs = script.getLinkCounterpartsByMetaMemeType(lbElement, u"DNA.Condition.Condition")
                    subjectPath = script.getEntityPropertyValue(lbElement, u"SubjectArgumentPath")
                    objectPath = script.getEntityPropertyValue(lbElement, u"ObjectArgumentPath")
                    conditionalStimuli = self.getConditionalStimuli(script, lbElement)
                    stateChange = StateChangeBreak(conditionIDs[0], conditionalStimuli)
                    stateChange.prime(subjectPath, objectPath)
                    self.stateChangesBreak.append(stateChange)
                    
                for saElement in saElements:
                    conditionIDs = script.getLinkCounterpartsByMetaMemeType(saElement, u"DNA.Condition.Condition")
                    priority = script.getEntityPropertyValue(conditionIDs[0], u"priority")
                    followOnActions = script.getLinkCounterpartsByMetaMemeType(saElement, u"Memotica.Action.Action")
                    insertionTypeStr = script.getEntityPropertyValue(saElement, u"InsertionType")
                    
                    insertionType = actionInsertionTypes.APPEND
                    if insertionTypeStr == u"Head":
                        linkType = 1
                    elif insertionTypeStr == u"HeadClear":
                        linkType = 2
                    conditionalStimuli = self.getConditionalStimuli(script, saElement)
                    stateChange = StateChangeSuccessorAction(conditionIDs[0], conditionalStimuli) 
                    stateChange.prime(followOnActions[0], insertionType, priority)
                    self.stateChangeSuccessor.append(stateChange)
                    
                    #Lastly, resort the successor action list to ensure that the new SA is positioned by priority
                    tempMap = {}
                    for currentEntry in self.stateChangeSuccessor:
                        tempMap[currentEntry.priority] = currentEntry
                    prioList = sorted(tempMap)
                    prioList.reverse()
                    
                    self.stateChangeSuccessor = [] 
                    for prio in prioList:
                        self.stateChangeSuccessor.append(tempMap[prio])
        except Exception as e:
            errorMsg = "Unknown error adding state change information to kexframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])

        
        
    def addStimuli(self, script):
        method = moduleName + '.' + self.className + '.' + 'addStimuli'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        #Memotica.Stimulus.ConditionalStimulus
        try:
            self.conditionalStimuli = self.getConditionalStimuli(script, self.uuid)
        except Exception as e:
            errorMsg = "Unknown error adding stimuli information to keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        
        

    def getConditionalStimuli(self, script, rootNodeID):
        """
        Keyframes may link to ConditionalStimulus elements directly, or indirectly via StateChange.  
            Also, general keyframe conditional stimuli are stored directly on the keyframe, while
            those associated with a state change belong to the state change and are only added 
            self.conditionalStimuli immediately prior to stimuli distribution, which follows state changes.
        """
        method = moduleName + '.' + self.className + '.' + 'getConditionalStimuli'
        try:
            #Memotica.Stimulus.StimulusChoice
            conditionalStimuli = []
            conditionalStimuli = script.getLinkCounterpartsByMetaMemeType(rootNodeID, u"Memotica.Stimulus.StimulusChoice")
            return conditionalStimuli
        except Exception as e:
            errorMsg = "Unknown error getting conditional stimuli for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return []
    
    
    def addRequiredCondition(self):
        #toto
        pass
        
        
    def addControllers(self, script):
        #Todo
        method = moduleName + '.' + self.className + '.' + 'addControllers'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            controllerBlacklist = None
            controllerWhitelist = None
            self.controllerBlacklist = controllerBlacklist
            self.controllerWhitelist = controllerWhitelist
        except Exception as e:
            errorMsg = "Unknown error adding controllers to keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        
        
    def addTimescale(self, script):
        method = moduleName + '.' + self.className + '.' + 'addTimescale'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            self.timescale = None
            timescaleElem = script.getLinkCounterpartsByMetaMemeType(self.uuid, u"Memotica.Action.Timescale")
            if len(timescaleElem) > 1:
                self.timescale = timescaleElem[0]
        except Exception as e:
            errorMsg = "Unknown error adding tiimescale to keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            
            
    def addRestrictedView(self, script):
        method = moduleName + '.' + self.className + '.' + 'addRestrictedView'
        #Graph.logQ.put( [logType , logLevel.DEBUG , method , "entering"])
        try:
            self.view = None
            viewElem = script.getLinkCounterpartsByMetaMemeType(self.uuid, u"Memotica.Action.View::Memotica.Agent.Page")
            if len(viewElem) > 1:
                self.view = viewElem[0]
        except Exception as e:
            errorMsg = "Unknown error adding view to keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        

        
    def mapFunctionObjects(self, script, objectID, rtParams):
        #We'll be adding objectID, passing on to script.map and really don't need any concurrency nonsense
        #    Hence the deepcopy
        method = moduleName + '.' + self.className + '.' + 'mapFunctionObjects'
        try:
            argumentMap = {}
            try:
                #If _angela_actionEngineModTest_responseQueue is a key in rtParams, then we are running in test mode.
                #    The key in question holds a queue object for the test action script.  Queue objects can't be copied!
                #    So we need to remove it from rtParams before making the copy and then re-add it to the copy.
                assert '_angela_actionEngineModTest_responseQueue' in rtParams
                responseQueue = rtParams['_angela_actionEngineModTest_responseQueue']
                del rtParams['_angela_actionEngineModTest_responseQueue']
                argumentMap = copy.deepcopy(rtParams)
                #now add the queue back to rtParams and to argumentMap...
                argumentMap['_angela_actionEngineModTest_responseQueue'] = responseQueue
                rtParams['_angela_actionEngineModTest_responseQueue'] = responseQueue
            except AssertionError:
                #We are not in test mode and can blindly take rtParams 
                argumentMap = copy.deepcopy(rtParams)
            except copy.Error as e:
                raise e
            except Exception as e:
                errorMsg = "Copy Error.  Traceback = %s" %(e)
                raise Exception(errorMsg)
            argumentMap["objectID"] = objectID
            localResult = None
            conditionResultSet = script.map(self.mapFunctionConditions, self.childConditions, argumentMap)
            if False not in conditionResultSet:
                localResult = objectID
            return localResult    
        except Exception as e:
            errorMsg = "Unknown error mapping objects for keyframe object of action %s.  rtparams = %s Traceback = %s" %(self.meme, rtParams, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return None
    
    
    def mapFunctionCheckEulerTransforms(self, landmarkTransform):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionCheckEulerTransforms'
        try:
            transformDict = landmarkTransform[1]
            transformResult = self.checkEulerAngles(landmarkTransform[0], transformDict["rotationX"], transformDict["rotationY"], transformDict["rotationZ"])
            return transformResult
        except Exception as e:
            errorMsg = "Unknown error mapping euler transforms for keyframe object of action %s.  landmarkTransform = %s Traceback = %s" %(self.meme, landmarkTransform[1], e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False
    
    
    def mapFunctionCheckDeltaTransforms(self, landmarkTransform):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionCheckDeltaTransforms'
        try:
            transformDict = landmarkTransform[1]
            transformResult = self.checkDeltas(landmarkTransform[0], transformDict["deltaX"], transformDict["deltaY"], transformDict["deltaZ"])
            return transformResult
        except Exception as e:
            errorMsg = "Unknown error mapping transform deltas for keyframe object of action %s.  landmarkTransform = %s Traceback = %s" %(self.meme, landmarkTransform[1], e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False
    
    
    def mapFunctionStateChangesInner(self, script, stateChange, argumentMap):
        #self.conditionID = conditionID
        #self.stateChangeStimuli = stateChangeStimuli
        method = moduleName + '.' + self.className + '.' + 'mapFunctionStateChangesInner'
        try:
            conditionResult = script.evaluateEntity(stateChange.conditionID, argumentMap, argumentMap["actionID"], argumentMap["subjectID"], argumentMap["controllerID"])
            if conditionResult == True:
                stateChange.execute(argumentMap["subjectID"], argumentMap["objectID"])
                self.conditionalStimuli.extend(stateChange.stateChangeStimuli)
        except Exception as e:
            errorMsg = "Unknown error mapping state change for keyframe object of action %s.  argumentMap = %s Traceback = %s" %(self.meme, argumentMap, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        finally: return None
            
    
    def mapFunctionStateChangesOuter(self, objectID, rtParams):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionStateChangesOuter'
        try:
            argumentMap = {}
            try:
                #If _angela_actionEngineModTest_responseQueue is a key in rtParams, then we are running in test mode.
                #    The key in question holds a queue object for the test action script.  Queue objects can't be copied!
                #    So we need to remove it from rtParams before making the copy and then re-add it to the copy.
                assert '_angela_actionEngineModTest_responseQueue' in rtParams
                responseQueue = rtParams['_angela_actionEngineModTest_responseQueue']
                del rtParams['_angela_actionEngineModTest_responseQueue']
                argumentMap = copy.deepcopy(rtParams)
                #now add the queue back to rtParams and to argumentMap...
                argumentMap['_angela_actionEngineModTest_responseQueue'] = responseQueue
                rtParams['_angela_actionEngineModTest_responseQueue'] = responseQueue
            except AssertionError:
                #We are not in test mode and can blindly take rtParams 
                argumentMap = copy.deepcopy(rtParams)
            except copy.Error as e:
                raise e
            except Exception as e:
                errorMsg = "Copy Error.  Traceback = %s" %(e)
                raise Exception(errorMsg)
            #argumentMap = copy.deepcopy(rtParams)
            argumentMap["objectID"] = objectID
            unusedReturn = self.script.map(self.mapFunctionStateChangesInner, self.stateChangesBreak, argumentMap)
            unusedReturn = self.script.map(self.mapFunctionStateChangesInner, self.stateChangesJoin, argumentMap)
            unusedReturn = self.script.map(self.mapFunctionStateChangesInner, self.stateChangesSimple, argumentMap)
            unusedReturn = self.script.map(self.mapFunctionStateChangesInner, self.stateChangeSuccessor, argumentMap)
        except copy.Error as e:
            #Logged as error instead of warning because an uncopyable paramater payload from a client may be indicative of an attempted attack.
            errorMsg = "Unable to map state change for keyframe object of action %s because runtime parameters contains an uncopyable object!  rtParams = %s" %(self.meme, rtParams)
            Graph.logQ.put( [logType , logLevel.ERROR , method , errorMsg])
        except Exception as e:
            errorMsg = "Unknown error mapping state change for keyframe object of action %s.  rtParams = %s Traceback = %s" %(self.meme, rtParams, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        finally: return None
    
    
    def mapFunctionSetEulerTransforms(self, script, landmarkTransform):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionSetEulerTransforms'
        try:
            transformDict = landmarkTransform[1]
            landmarkID = landmarkTransform[0]
            eulerElem = script.getLinkCounterpartsByMetaMemeType(landmarkID, u"Memotica.Agent.Offset::Memotica.Agent.EuerAngles")
            if len(eulerElem) > 0:
                eulerXElem = script.getLinkCounterpartsByMetaMemeType(eulerElem, u"Memotica.Agent.RotationX")
                eulerYElem = script.getLinkCounterpartsByMetaMemeType(eulerElem, u"Memotica.Agent.RotationX")
                eulerZElem = script.getLinkCounterpartsByMetaMemeType(eulerElem, u"Memotica.Agent.RotationX")
                unusedEulerX = script.setEntityPropertyValue(eulerXElem[0], u"Angle", transformDict["rotationX"])
                unusedEulerY = script.setEntityPropertyValue(eulerYElem[0], u"Angle", transformDict["rotationY"])
                unusedEulerZ = script.setEntityPropertyValue(eulerZElem[0], u"Angle", transformDict["rotationZ"])
        except Exception as e:
            errorMsg = "Unknown error mapping euler transforms for keyframe object of action %s.  landmarkTransform = %s Traceback = %s" %(self.meme, landmarkTransform[1], e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        finally: return True
    
    
    def mapFunctionSetDeltaTransforms(self, script, landmarkTransform):
        method = moduleName + '.' + self.className + '.' + 'mapFunctionSetDeltaTransforms'
        try:
            transformDict = landmarkTransform[1]
            landmarkID = landmarkTransform[0]
            offsetElem = script.getLinkCounterpartsByMetaMemeType(landmarkID, u"Memotica.Agent.Offset")
            if len(offsetElem) > 0:
                unusedDeltaX = script.setEntityPropertyValue(offsetElem[0], u"x", transformDict["deltaX"])
                unusedDeltaY = script.setEntityPropertyValue(offsetElem[0], u"y", transformDict["deltaY"])
                unusedDeltaZ = script.setEntityPropertyValue(offsetElem[0], u"z", transformDict["deltaZ"])
        except Exception as e:
            errorMsg = "Unknown error mapping delta transforms for keyframe object of action %s.  landmarkTransform = %s Traceback = %s" %(self.meme, landmarkTransform[1], e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        finally: return True
        

    def checkEulerAngles(self, script, landmarkUUID, rotationX, rotationY, rotationZ):
        """
            If the euler angles of the keyframe are not all None, then check them against constraints 
        """
        method = moduleName + '.' + self.className + '.' + 'checkEulerAngles'
        try:
            if (rotationX is None) and (rotationY is None) and (rotationZ is None):
                return
            anglesMax = script.getLinkCounterpartsByMetaMemeType(landmarkUUID, u"Memotica.Agent.EulerAnglesMax")
            #First the max
            if len(anglesMax) > 0:
                maxRotationXElem = script.getLinkCounterpartsByMetaMemeType(anglesMax[0], u"Memotica.Agent.RotationX")
                maxRotationYElem = script.getLinkCounterpartsByMetaMemeType(anglesMax[0], u"Memotica.Agent.RotationX")
                maxRotationZElem = script.getLinkCounterpartsByMetaMemeType(anglesMax[0], u"Memotica.Agent.RotationX")
                maxRotationX = script.getEntityPropertyValue(maxRotationXElem[0], u"Angle")
                maxRotationY = script.getEntityPropertyValue(maxRotationYElem[0], u"Angle")
                maxRotationZ = script.getEntityPropertyValue(maxRotationZElem[0], u"Angle")
                if (rotationX is not None) and (maxRotationX is not None):
                    if rotationX > maxRotationX:
                        raise Exceptions.EntityMaxXAngleExceeded("%s > %s" %[rotationX, maxRotationX])
                if (rotationY is not None) and (maxRotationY is not None):
                    if rotationY > maxRotationY:
                        raise Exceptions.EntityMaxYAngleExceeded("%s > %s" %[rotationX, maxRotationX])
                if (rotationZ is not None) and (maxRotationZ is not None):
                    if rotationZ > maxRotationZ:
                        raise Exceptions.EntityMaxZAngleExceeded("%s > %s" %[rotationX, maxRotationX])
            #Then the min
            anglesMin = script.getLinkCounterpartsByMetaMemeType(landmarkUUID, u"Memotica.Agent.EulerAnglesMin")
            if len(anglesMin) > 0:
                minRotationXElem = script.getLinkCounterpartsByMetaMemeType(anglesMin[0], u"Memotica.Agent.RotationX")
                minRotationYElem = script.getLinkCounterpartsByMetaMemeType(anglesMin[0], u"Memotica.Agent.RotationX")
                minRotationZElem = script.getLinkCounterpartsByMetaMemeType(anglesMin[0], u"Memotica.Agent.RotationX")
                minRotationX = script.getEntityPropertyValue(minRotationXElem[0], u"Angle")
                minRotationY = script.getEntityPropertyValue(minRotationYElem[0], u"Angle")
                minRotationZ = script.getEntityPropertyValue(minRotationZElem[0], u"Angle")
                if (rotationX is not None) and (minRotationX is not None):
                    if rotationX < minRotationX:
                        raise Exceptions.EntityMaxXAngleExceeded("%s < %s" %[rotationX, maxRotationX])
                if (rotationY is not None) and (minRotationY is not None):
                    if rotationY < minRotationY:
                        raise Exceptions.EntityMaxYAngleExceeded("%s < %s" %[rotationX, maxRotationX])
                if (rotationZ is not None) and (minRotationZ is not None):
                    if rotationZ < minRotationZ:
                        raise Exceptions.EntityMaxZAngleExceeded("%s < %s" %[rotationX, maxRotationX])
        except Exception as e:
            errorMsg = "Unknown error checking euler angles for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
                


    def checkDeltas(self, script, landmarkUUID, deltaX, deltaY, deltaZ):
        method = moduleName + '.' + self.className + '.' + 'checkDeltas'
        try:
            def checkAngles(self, landmarkUUID, rotationX, rotationY, rotationZ):
                #First the max
                deltasMax = script.getLinkCounterpartsByMetaMemeType(landmarkUUID, u"Memotica.Agent.OffsetMax")
                if len(deltasMax) > 0:
                    maxDeltaX = script.getEntityPropertyValue(deltasMax[0], u"x")
                    maxDeltaY = script.getEntityPropertyValue(deltasMax[0], u"y")
                    maxDeltaZ = script.getEntityPropertyValue(deltasMax[0], u"z")
                    if (deltaX is not None) and (maxDeltaX is not None):
                        if deltaX > maxDeltaX:
                            raise Exceptions.EntityMaxXOffsetExceeded("%s > %s" %[deltaX, maxDeltaX])
                    if (deltaY is not None) and (maxDeltaY is not None):
                        if deltaY > maxDeltaY:
                            raise Exceptions.EntityMaxYOffsetExceeded("%s > %s" %[deltaY, maxDeltaY])
                    if (deltaZ is not None) and (maxDeltaZ is not None):
                        if deltaZ > maxDeltaZ:
                            raise Exceptions.EntityMaxZOffsetExceeded("%s > %s" %[deltaZ, maxDeltaZ])
                #Then the min
                deltasMin = script.getLinkCounterpartsByMetaMemeType(landmarkUUID, u"Memotica.Agent.OffsetMin")
                if len(deltasMin) > 0:
                    minDeltaX = script.getEntityPropertyValue(deltasMax[0], u"x")
                    minDeltaY = script.getEntityPropertyValue(deltasMax[0], u"y")
                    minDeltaZ = script.getEntityPropertyValue(deltasMax[0], u"z")
                    if (deltaX is not None) and (minDeltaX is not None):
                        if deltaX > minDeltaX:
                            raise Exceptions.EntityMinXOffsetExceeded("%s > %s" %[deltaX, minDeltaX])
                    if (deltaY is not None) and (minDeltaY is not None):
                        if deltaY > minDeltaY:
                            raise Exceptions.EntityMinYOffsetExceeded("%s > %s" %[deltaY, minDeltaY])
                    if (deltaZ is not None) and (minDeltaZ is not None):
                        if deltaZ > minDeltaZ:
                            raise Exceptions.EntityMinZOffsetExceeded("%s > %s" %[deltaZ, minDeltaZ])
        except Exception as e:
            errorMsg = "Unknown error checking entity displacement (deltas) for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])

    
    def checkTransforms(self, script, agentID):
        method = moduleName + '.' + self.className + '.' + 'checkTransforms'
        try:
            #transformDict = {"deltaX" : deltaX, "deltaY" : deltaY, "deltaZ" : deltaZ, "rotationX" : rotationX, "rotationY" : rotationY, "rotationZ" : rotationZ}
            #self.landmarkTransforms.append([reqLMs[0], transformDict])
            transformsOK = []
            eulerOK = script.map(self.mapFunctionCheckEulerTransforms, self.landmarkTransforms, agentID)
            deltaOK = script.map(self.mapFunctionCheckDeltaTransforms, self.landmarkTransforms, agentID)
            transformsOK.extend(eulerOK)
            transformsOK.extend(deltaOK)
            if False in transformsOK:
                return False
            else:
                return True    
        except Exception as e:
            errorMsg = "Unknown error checking transforms for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return False
    # /Landmarks
 
    
    # objects
    def selectObjects(self, script, rtParams, objectID = None):
        """
            Select all object agents in scope of view that also meet the conditions required for selection:
                'Memotica.Action.ObjectSelectionCondition::DNA.Condition.Condition'
            Here are the rules:
                If there is a view with an action perspective, we limit ourselves to that scope
                    If there are no selection conditions and no objectID, all agents in scope are selected
                    If objectID is selected and it is not in scope, the action is dropped
                    If objectID is selected and in scope, the action goes to that object, plus others in scope meeting conditions
                    If objectID is not in scope, but other objects are and meet the conditions, they get the action, but not objectID
                If there is no action perspective (View directly off of KeyFrame instead of via Landmark on subject)
                    If there are no selection conditions and no objectID; dropped
                    If there are no selection conditions, but objectID; the action goes to that object 
        """
        method = moduleName + '.' + self.className + '.' + 'selectObjects'
        try:
            if self.view is not None:
                #Use 'action perspective' view
                if (len(self.objectSelectionConditions) < 1) and (objectID is None):
                    viewList = script.getAllAgentsInSpecifiedPage(self.view)
                    return viewList
                elif (len(self.objectSelectionConditions) < 1) and (objectID is not None):
                    viewList = script.getAllAgentsInSpecifiedPage(self.view)
                    if objectID in viewList:
                        return [objectID]
                    else:
                        return []
                else:
                    intersectedObjects = script.getAllAgentsInAgentView(rtParams["subjectID"])
                    viewList = script.map(self.mapFunctionObjects, intersectedObjects, rtParams)
                    viewList.remove(None)
                    return viewList
            else:
                #Use 'subject perspective' view
                if (len(self.objectSelectionConditions) < 1) and (objectID is None):
                    return []
                elif (len(self.objectSelectionConditions) < 1) and (objectID is not None):
                    return [objectID]
                elif objectID is not None:
                    intersectedObjects = script.getAllAgentsInAgentView(rtParams["subjectID"])
                    viewList = script.map(self.mapFunctionObjects, intersectedObjects, rtParams)
                    viewList.remove(None)
                    if objectID not in viewList:
                        viewList.append(objectID)
                    return viewList
                else:
                    intersectedObjects = script.getAllAgentsInAgentView(rtParams["subjectID"])
                    viewList = script.map(self.mapFunctionObjects, intersectedObjects, rtParams)
                    viewList.remove(None)
                    return viewList
        except Exception as e:
            errorMsg = "Unknown error selecting object entities for keyframe object of action %s.  rtParams = %s Traceback = %s" %(self.meme, rtParams, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
            return []
    # /objects
    
    
    # State Changes
    def changeStates(self, script, rtParams):
        method = moduleName + '.' + self.className + '.' + 'changeStates'
        try:
            self.script = script
            stateChangeStimuli = script.map(self.mapFunctionStateChangesOuter, rtParams["objectID"], rtParams)
            self.conditionalStimuli.extend(stateChangeStimuli)
        except Exception as e:
            errorMsg = "Unknown error changing states for keyframe object of action %s.  rtParams = %s Traceback = %s" %(self.meme, rtParams, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
    #/ State Changes
    
    
    #Transforms
    def setTransforms(self, script, objectIDs):
        method = moduleName + '.' + self.className + '.' + 'setTransforms'
        try:
            unusedEulerDone = script.map(self.mapFunctionSetEulerTransforms, self.landmarkTransforms, objectIDs)
            unusedDeltaDone = script.map(self.mapFunctionSetDeltaTransforms, self.landmarkTransforms, objectIDs)
        except Exception as e:
            errorMsg = "Unknown error setting transforms for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
    #/Transforms
    
    
    # Stimuli
    def broadcastStimuli(self, script, rtParams):
        method = moduleName + '.' + self.className + '.' + 'broadcastStimuli'
        try:
            for conditionalStimulus in self.conditionalStimuli:
                if conditionalStimulus is not None:
                    stimulusMessage = None
                    #Angela.StimulusMessage def __init__(self, stimulusID, argumentMap, targetAgents = []):
                    if rtParams.has_key("stimuliRecipients") == True:
                        targets = rtParams["stimuliRecipients"]
                        stimulusMessage = Angela.StimulusMessage(conditionalStimulus, rtParams, targets)
                    else:
                        stimulusMessage = Angela.StimulusMessage(conditionalStimulus, rtParams, [])
                    Engine.siQ.put(stimulusMessage)
        except Exception as e:
            errorMsg = "Unknown error broadcasting stimuli for keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])


    def invoke(self, script, rtParams, subjectID, controllerID):
        method = moduleName + '.' + self.className + '.' + 'invoke'
        try:
            #todo - refactor script.evaluateEntity to add objects
            script.evaluateEntity(self.uuid, rtParams, self.uuid, subjectID, controllerID, True)
        except Exception as e:
            errorMsg = "Unknown error invoking keyframe object of action %s.  Traceback = %s" %(self.meme, e)
            Graph.logQ.put( [logType , logLevel.WARNING , method , errorMsg])
        



class Catch(Action, ConditionalAction):
    className = 'Catch'
    
    def bootstrap(self, script):
        self.addConditions(script)
        self.addLandMarks(script)




class Throw(Action, ConditionalAction):
    className = 'Throw'
    def bootstrap(self, script):
        self.addConditions(script)
        self.addLandMarks(script)



class StateChange(object):
    def __init__(self, conditionID, stateChangeStimuli = []):
        self.conditionID = conditionID
        self.stateChangeStimuli = stateChangeStimuli
                
       
class StateChangeBreak(StateChange):
    def prime(self, subjectPath, objectPath):
        self.subjectPath = subjectPath
        self.objectPath = objectPath    
    
    def execute(self, script, subjectID, objectID):
        script.removeEntityLink(subjectID, objectID)
        self
        
        
class StateChangeJoin(StateChange):
    def prime(self, subjectPath, objectPath, linkType):
        self.linkType = linkType
        self.subjectPath = subjectPath
        self.objectPath = objectPath
    
    def execute(self, script, subjectID, objectID):
        subjectMountPoint = script.getLinkCounterpartsByMetaMemeType(subjectID, self.subjectPath)
        objectMountPoint = script.getLinkCounterpartsByMetaMemeType(subjectID, self.objectPath)
        script.addEntityLink(subjectMountPoint[0], objectMountPoint[0], self.linkType)
        
        
class StateChangeSimple(StateChange):
    def prime(self, changeID, path):
        #channgeID is the uuid of the relevant Numeric.Function entity
        #stateID is the path to be changed
        self.changeID = changeID 
        self.path = path
        
    def execute(self, script, subjectID, objectID):
        #todo - thuis requires an overhaul of how Numeric.Function is processed
        delta = script.evaluateEntity(self.changeID)  
        oldPropValue = script.getEntityPropertyValue(objectID, self.path)
        newPropValue = oldPropValue + delta
        script.setEntityPropertyValue(objectID, self.path, newPropValue) 
    

    
class StateChangeSuccessorAction(StateChange):
    def prime(self, actionID, insertionType, priority):
        self.actionID = actionID 
        self.insertionType = insertionType
        self.priority = priority
        
    def execute(self, subjectID, objectID):
        #todo -
        actionInvoc = {"actionID" : self.actionID, "subjectID" : subjectID, "objectID" : objectID, "controllerID" : None, "insertionType" : self.insertionType, "rtparams" : {}}
        Engine.aQ.put(actionInvoc) 
        
        
#globals



def getActionIndexItem(script, toBeIndexed):
    method = moduleName + '.' + 'getActionIndexItem'
    Graph.logQ.put( [logType , logLevel.DEBUG ,  method, " - entering"])
    
    try:
        actionMemes = []
        action = None
        
        actionMemes = script.getLinkCounterpartsByMetaMemeType(toBeIndexed, u"Memotica.Action.Throw")
        if len(actionMemes) > 0:
            Graph.logQ.put( [logType , logLevel.DEBUG ,  method, "Action %s is a Throw" %toBeIndexed])
            try:
                action = Throw()
                action.initialize(script, actionMemes[0], toBeIndexed)
            except Exception as e:
                actionMeme = None
                try: actionMeme = actionMemes[0]
                except: pass
                errorMsg = "Member Memotica.Action.Throw entity %s is invalid" %actionMeme
                raise Exceptions.TemplatePathError(errorMsg)
        else:
            actionMemes = script.getLinkCounterpartsByMetaMemeType(toBeIndexed, u"Memotica.Action.Catch")
            if len(actionMemes) > 0:
                Graph.logQ.put( [logType , logLevel.DEBUG ,  method, "Action %s is a Catch" %toBeIndexed])
                try:
                    action = Catch()
                    action.initialize(script, actionMemes[0], toBeIndexed)
                except Exception as e:
                    actionMeme = None
                    try: actionMeme = actionMemes[0]
                    except: pass
                    errorMsg = "Member Memotica.Action.Catch entity %s is invalid" %actionMeme
                    raise Exceptions.TemplatePathError(errorMsg)
            else:
                actionMemes = script.getLinkCounterpartsByMetaMemeType(toBeIndexed, u"Memotica.Action.Choreography")
                if len(actionMemes) > 0:
                    Graph.logQ.put( [logType , logLevel.DEBUG ,  method, "Action %s is a Choreography" %toBeIndexed])
                    try:
                        action = ActionSet()
                        action.initialize(script, actionMemes[0], toBeIndexed)
                    except Exception as e:
                        actionMeme = None
                        try: actionMeme = actionMemes[0]
                        except: pass
                        errorMsg = "Member Memotica.Action.Choreography entity %s is invalid" %actionMeme
                        raise Exceptions.TemplatePathError(errorMsg)
                else:
                    actionMemes = script.getLinkCounterpartsByMetaMemeType(toBeIndexed, u"Memotica.Action.KeyFrame")
                    if len(actionMemes) > 0:
                        Graph.logQ.put( [logType , logLevel.DEBUG ,  method, "Action %s is a KeyFrame" %toBeIndexed])
                        try:
                            action = KeyFrame()
                            action.initialize(script, actionMemes[0], toBeIndexed)
                        except Exception as e:
                            actionMeme = None
                            try: actionMeme = actionMemes[0]
                            except: pass
                            errorMsg = "Member Memotica.Action.KeyFrame entity %s is invalid" %actionMeme
                            raise Exceptions.TemplatePathError(errorMsg)
                    else:
                        actionType = script.getEntityMemeType(toBeIndexed)
                        linkOverview = script.getCounterpartOverview(toBeIndexed)
                        errorMsg = "Action %s has no valid child type.  Link overview = %s" %(actionType, linkOverview)
                        Graph.logQ.put( [logType , logLevel.WARNING , method, errorMsg])
        #now finish creating the action object
        action.bootstrap(script)
        Graph.logQ.put( [logType , logLevel.DEBUG , method, "Bootstrapped %s %s" %(type(action), action.meme)])
        Graph.logQ.put( [logType , logLevel.DEBUG ,  method, " - exiting"])
        return action
    except Exceptions.ScriptError as e:
        actionMeme = script.getEntityMemeType(toBeIndexed)
        errorMsg = "Error in DNA method while creating action index item %s.  Traceback = %s" %(actionMeme, e)
        Graph.logQ.put( [logType , logLevel.WARNING ,  method, errorMsg])
        raise e        
    except Exception as e:
        actionMeme = script.getEntityMemeType(toBeIndexed)
        errorMsg = "Error creating action index item %s.  Traceback = %s" %(actionMeme, e)
        Graph.logQ.put( [logType , logLevel.WARNING ,  method, errorMsg])
        raise e

        



def usage():
    print(__doc__)

    
def main(argv):
    pass
    
    
if __name__ == "__main__":
    pass
